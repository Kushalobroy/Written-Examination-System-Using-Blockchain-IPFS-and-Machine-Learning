(function (root, factory) {(typeof module === 'object' && module.exports) ? module.exports = factory() : root.Libp2PInterface = factory()}(typeof self !== 'undefined' ? self : this, function () {
"use strict";var Libp2PInterface=(()=>{var n=Object.defineProperty;var L=Object.getOwnPropertyDescriptor;var _=Object.getOwnPropertyNames;var g=Object.prototype.hasOwnProperty;var I=(e,t)=>{for(var o in t)n(e,o,{get:t[o],enumerable:!0})},N=(e,t,o,s)=>{if(t&&typeof t=="object"||typeof t=="function")for(let r of _(t))!g.call(e,r)&&r!==o&&n(e,r,{get:()=>t[r],enumerable:!(s=L(t,r))||s.enumerable});return e};var T=e=>N(n({},"__esModule",{value:!0}),e);var q={};I(q,{AbortError:()=>i,AggregateCodeError:()=>l,CodeError:()=>a,CustomEvent:()=>b,ERR_INVALID_MESSAGE:()=>Y,ERR_INVALID_PARAMETERS:()=>j,ERR_NOT_FOUND:()=>X,ERR_TIMEOUT:()=>G,Ed25519:()=>P,FaultTolerance:()=>p,InvalidCryptoExchangeError:()=>x,InvalidCryptoTransmissionError:()=>u,KEEP_ALIVE:()=>U,RSA:()=>M,StrictNoSign:()=>B,StrictSign:()=>k,TopicValidatorResult:()=>c,TypedEventEmitter:()=>d,UnexpectedPeerError:()=>f,connectionSymbol:()=>R,contentRoutingSymbol:()=>w,isConnection:()=>v,isPeerId:()=>V,isStartable:()=>S,isTransport:()=>F,peerDiscoverySymbol:()=>D,peerIdSymbol:()=>h,peerRoutingSymbol:()=>C,secp256k1:()=>O,setMaxListeners:()=>m,start:()=>H,stop:()=>K,transportSymbol:()=>A});var R=Symbol.for("@libp2p/connection");function v(e){return e!=null&&!!e[R]}var w=Symbol.for("@libp2p/content-routing");var P="Ed25519",M="RSA",O="secp256k1";var D=Symbol.for("@libp2p/peer-discovery");var h=Symbol.for("@libp2p/peer-id");function V(e){return e!=null&&!!e[h]}var C=Symbol.for("@libp2p/peer-routing");var U="keep-alive";var k="StrictSign",B="StrictNoSign",c;(function(e){e.Accept="accept",e.Ignore="ignore",e.Reject="reject"})(c||(c={}));var A=Symbol.for("@libp2p/transport");function F(e){return e!=null&&!!e[A]}var p;(function(e){e[e.FATAL_ALL=0]="FATAL_ALL",e[e.NO_FATAL=1]="NO_FATAL"})(p||(p={}));var i=class e extends Error{code;type;constructor(t="The operation was aborted"){super(t),this.code=e.code,this.type=e.type}static code="ABORT_ERR";static type="aborted"},a=class extends Error{code;props;constructor(t,o,s){super(t),this.code=o,this.name=s?.name??"CodeError",this.props=s??{}}},l=class extends AggregateError{code;props;constructor(t,o,s,r){super(t,o),this.code=s,this.name=r?.name??"AggregateCodeError",this.props=r??{}}},f=class e extends Error{code;constructor(t="Unexpected Peer"){super(t),this.code=e.code}static code="ERR_UNEXPECTED_PEER"},x=class e extends Error{code;constructor(t="Invalid crypto exchange"){super(t),this.code=e.code}static code="ERR_INVALID_CRYPTO_EXCHANGE"},u=class e extends Error{code;constructor(t="Invalid crypto transmission"){super(t),this.code=e.code}static code="ERR_INVALID_CRYPTO_TRANSMISSION"},G="ERR_TIMEOUT",j="ERR_INVALID_PARAMETERS",X="ERR_NOT_FOUND",Y="ERR_INVALID_MESSAGE";var m=(e,...t)=>{try{[...t]}catch{}};var d=class extends EventTarget{#t=new Map;constructor(){super(),m(1/0,this)}listenerCount(t){let o=this.#t.get(t);return o==null?0:o.length}addEventListener(t,o,s){super.addEventListener(t,o,s);let r=this.#t.get(t);r==null&&(r=[],this.#t.set(t,r)),r.push({callback:o,once:(s!==!0&&s!==!1&&s?.once)??!1})}removeEventListener(t,o,s){super.removeEventListener(t.toString(),o??null,s);let r=this.#t.get(t);r!=null&&(r=r.filter(({callback:y})=>y!==o),this.#t.set(t,r))}dispatchEvent(t){let o=super.dispatchEvent(t),s=this.#t.get(t.type);return s==null||(s=s.filter(({once:r})=>!r),this.#t.set(t.type,s)),o}safeDispatchEvent(t,o={}){return this.dispatchEvent(new b(t,o))}},E=class extends Event{detail;constructor(t,o){super(t,o),this.detail=o?.detail}},b=globalThis.CustomEvent??E;function S(e){return e!=null&&typeof e.start=="function"&&typeof e.stop=="function"}async function H(...e){let t=[];for(let o of e)S(o)&&t.push(o);await Promise.all(t.map(async o=>{o.beforeStart!=null&&await o.beforeStart()})),await Promise.all(t.map(async o=>{await o.start()})),await Promise.all(t.map(async o=>{o.afterStart!=null&&await o.afterStart()}))}async function K(...e){let t=[];for(let o of e)S(o)&&t.push(o);await Promise.all(t.map(async o=>{o.beforeStop!=null&&await o.beforeStop()})),await Promise.all(t.map(async o=>{await o.stop()})),await Promise.all(t.map(async o=>{o.afterStop!=null&&await o.afterStop()}))}return T(q);})();
return Libp2PInterface}));
